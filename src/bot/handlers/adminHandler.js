const logger = require('../../utils/logger');
const User = require('../../database/models/User');
const Whitelist = require('../../database/models/Whitelist');
const PredictionModel = require('../../database/models/PredictionModel');
const BackupLog = require('../../database/models/BackupLog');
const { createDatabaseBackup, restoreDatabaseFromBackup } = require('../../utils/backupUtils');
const { validateModelFile } = require('../../ml/predictionService');
const fs = require('fs');
const path = require('path');
const { v4: uuidv4 } = require('uuid');
const { exec } = require('child_process');
const util = require('util');
const execPromise = util.promisify(exec);

/**
 * Add a user to the whitelist
 * @param {TelegramBot} bot - Telegram bot instance
 * @param {Object} msg - Message object from Telegram
 * @param {string} targetTelegramId - Telegram ID to add to whitelist
 * @param {string} name - Name of the user
 */
async function addUserToWhitelist(bot, msg, targetTelegramId, name) {
  const chatId = msg.chat.id;
  const adminId = msg.from.id.toString();
  
  try {
    // Check if user already exists
    const [user, userCreated] = await User.findOrCreate({
      where: { telegramId: targetTelegramId },
      defaults: {
        name,
        isAdmin: false
      }
    });
    
    // Check if already whitelisted
    const [whitelist, whitelistCreated] = await Whitelist.findOrCreate({
      where: { telegramId: targetTelegramId },
      defaults: {
        addedBy: adminId
      }
    });
    
    if (!whitelistCreated) {
      await bot.sendMessage(
        chatId,
        `‚ö†Ô∏è –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å ID ${targetTelegramId} —É–∂–µ –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤ –±–µ–ª–æ–º —Å–ø–∏—Å–∫–µ.`
      );
      return;
    }
    
    // If the user was just created, update their name
    if (!userCreated) {
      user.name = name;
      await user.save();
    }
    
    await bot.sendMessage(
      chatId,
      `‚úÖ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å ${name} (ID: ${targetTelegramId}) —É—Å–ø–µ—à–Ω–æ –¥–æ–±–∞–≤–ª–µ–Ω –≤ –±–µ–ª—ã–π —Å–ø–∏—Å–æ–∫.`
    );
    
    logger.info(`Admin ${adminId} added user ${targetTelegramId} to whitelist`);
  } catch (error) {
    logger.error(`Error adding user to whitelist: ${error.message}`);
    await bot.sendMessage(
      chatId,
      '‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ –±–µ–ª—ã–π —Å–ø–∏—Å–æ–∫. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.'
    );
  }
}

/**
 * Remove a user from the whitelist
 * @param {TelegramBot} bot - Telegram bot instance
 * @param {Object} msg - Message object from Telegram
 * @param {string} targetTelegramId - Telegram ID to remove from whitelist
 */
async function removeUserFromWhitelist(bot, msg, targetTelegramId) {
  const chatId = msg.chat.id;
  const adminId = msg.from.id.toString();
  
  try {
    // Check if user is in whitelist
    const whitelist = await Whitelist.findOne({
      where: { telegramId: targetTelegramId }
    });
    
    if (!whitelist) {
      await bot.sendMessage(
        chatId,
        `‚ö†Ô∏è –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å ID ${targetTelegramId} –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –±–µ–ª–æ–º —Å–ø–∏—Å–∫–µ.`
      );
      return;
    }
    
    // Remove from whitelist
    await whitelist.destroy();
    
    await bot.sendMessage(
      chatId,
      `‚úÖ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å ID ${targetTelegramId} —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω –∏–∑ –±–µ–ª–æ–≥–æ —Å–ø–∏—Å–∫–∞.`
    );
    
    logger.info(`Admin ${adminId} removed user ${targetTelegramId} from whitelist`);
  } catch (error) {
    logger.error(`Error removing user from whitelist: ${error.message}`);
    await bot.sendMessage(
      chatId,
      '‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏–∑ –±–µ–ª–æ–≥–æ —Å–ø–∏—Å–∫–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.'
    );
  }
}

/**
 * List all users in the whitelist
 * @param {TelegramBot} bot - Telegram bot instance
 * @param {Object} msg - Message object from Telegram
 */
async function listWhitelistedUsers(bot, msg) {
  const chatId = msg.chat.id;
  
  try {
    // Get all whitelist entries with user info
    const whitelistEntries = await Whitelist.findAll({
      include: [
        {
          model: User,
          attributes: ['telegramId', 'name', 'isAdmin']
        }
      ]
    });
    
    if (whitelistEntries.length === 0) {
      await bot.sendMessage(
        chatId,
        'üìù –ë–µ–ª—ã–π —Å–ø–∏—Å–æ–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –ø—É—Å—Ç.'
      );
      return;
    }
    
    // Format the whitelist message
    let whitelistText = `üë• *–°–ø–∏—Å–æ–∫ —Ä–∞–∑—Ä–µ—à–µ–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π* (${whitelistEntries.length})\n\n`;
    
    for (const entry of whitelistEntries) {
      const user = entry.User;
      const addedDate = new Date(entry.addedAt).toLocaleDateString('ru-RU');
      
      whitelistText += `*ID:* ${user.telegramId}\n`;
      whitelistText += `*–ò–º—è:* ${user.name || '–ù–µ —É–∫–∞–∑–∞–Ω–æ'}\n`;
      whitelistText += `*–ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä:* ${user.isAdmin ? '–î–∞' : '–ù–µ—Ç'}\n`;
      whitelistText += `*–î–æ–±–∞–≤–ª–µ–Ω:* ${addedDate}\n\n`;
    }
    
    await bot.sendMessage(chatId, whitelistText, { parse_mode: 'Markdown' });
    logger.info(`Admin ${msg.from.id} listed whitelisted users`);
  } catch (error) {
    logger.error(`Error listing whitelisted users: ${error.message}`);
    await bot.sendMessage(
      chatId,
      '‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å–ø–∏—Å–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.'
    );
  }
}

/**
 * List all prediction models
 * @param {TelegramBot} bot - Telegram bot instance
 * @param {Object} msg - Message object from Telegram
 */
async function listModels(bot, msg) {
  const chatId = msg.chat.id;
  
  try {
    // Get all models
    const models = await PredictionModel.findAll({
      order: [
        ['name', 'ASC'],
        ['isActive', 'DESC'],
        ['trainedDate', 'DESC']
      ]
    });
    
    if (models.length === 0) {
      await bot.sendMessage(
        chatId,
        'üìù –°–ø–∏—Å–æ–∫ –º–æ–¥–µ–ª–µ–π –ø—É—Å—Ç. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—É `/admin model reload` –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ –º–æ–¥–µ–ª–µ–π.'
      );
      return;
    }
    
    // Format the models message
    let modelsText = `üß† *–°–ø–∏—Å–æ–∫ –º–æ–¥–µ–ª–µ–π –ø—Ä–æ–≥–Ω–æ–∑–∏—Ä–æ–≤–∞–Ω–∏—è* (${models.length})\n\n`;
    
    for (const model of models) {
      const trainedDate = new Date(model.trainedDate).toLocaleDateString('ru-RU');
      const metrics = model.metrics ? JSON.stringify(model.metrics) : '–ù–µ —É–∫–∞–∑–∞–Ω—ã';
      
      modelsText += `*–ù–∞–∑–≤–∞–Ω–∏–µ:* ${model.name}\n`;
      modelsText += `*–í–µ—Ä—Å–∏—è:* ${model.version}\n`;
      modelsText += `*–î–∞—Ç–∞ –æ–±—É—á–µ–Ω–∏—è:* ${trainedDate}\n`;
      modelsText += `*–ú–µ—Ç—Ä–∏–∫–∏:* ${metrics}\n`;
      modelsText += `*–ü—É—Ç—å:* ${model.filePath}\n`;
      modelsText += `*–ê–∫—Ç–∏–≤–Ω–∞:* ${model.isActive ? '‚úÖ' : '‚ùå'}\n\n`;
    }
    
    await bot.sendMessage(chatId, modelsText, { parse_mode: 'Markdown' });
    logger.info(`Admin ${msg.from.id} listed prediction models`);
  } catch (error) {
    logger.error(`Error listing models: ${error.message}`);
    await bot.sendMessage(
      chatId,
      '‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å–ø–∏—Å–∫–∞ –º–æ–¥–µ–ª–µ–π. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.'
    );
  }
}

/**
 * Reload prediction models
 * @param {TelegramBot} bot - Telegram bot instance
 * @param {Object} msg - Message object from Telegram
 * @param {string} sizeModelPath - Path to the size model file
 * @param {string} pdiModelPath - Path to the PDI model file
 */
async function reloadModels(bot, msg, sizeModelPath, pdiModelPath) {
  const chatId = msg.chat.id;
  const adminId = msg.from.id.toString();
  
  try {
    // Check if files exist
    if (!fs.existsSync(sizeModelPath) || !fs.existsSync(pdiModelPath)) {
      await bot.sendMessage(
        chatId,
        '‚ùå –û–¥–∏–Ω –∏–ª–∏ –æ–±–∞ —Ñ–∞–π–ª–∞ –º–æ–¥–µ–ª–µ–π –Ω–µ –Ω–∞–π–¥–µ–Ω—ã. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ø—É—Ç–∏ –∏ –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.'
      );
      return;
    }
    
    // Validate models
    const sizeModelValid = await validateModelFile(sizeModelPath);
    const pdiModelValid = await validateModelFile(pdiModelPath);
    
    if (!sizeModelValid || !pdiModelValid) {
      await bot.sendMessage(
        chatId,
        '‚ùå –û–¥–∏–Ω –∏–ª–∏ –æ–±–∞ —Ñ–∞–π–ª–∞ –º–æ–¥–µ–ª–µ–π –Ω–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ —Ñ–∞–π–ª—ã –∏ –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.'
      );
      return;
    }
    
    // Deactivate all existing models
    await PredictionModel.update(
      { isActive: false },
      { where: {} }
    );
    
    // Create directory for models if it doesn't exist
    const modelsDir = path.join(__dirname, '../../../models');
    if (!fs.existsSync(modelsDir)) {
      fs.mkdirSync(modelsDir, { recursive: true });
    }
    
    // Copy and register size model
    const sizeModelDestPath = path.join(modelsDir, `size_model_${Date.now()}.keras`);
    fs.copyFileSync(sizeModelPath, sizeModelDestPath);
    
    await PredictionModel.create({
      name: 'size_model',
      version: `${new Date().toISOString().slice(0, 10)}`,
      trainedDate: new Date(),
      metrics: { r2: 0.85 }, // Default metrics, should be updated with actual values
      filePath: sizeModelDestPath,
      isActive: true
    });
    
    // Copy and register PDI model
    const pdiModelDestPath = path.join(modelsDir, `pdi_model_${Date.now()}.keras`);
    fs.copyFileSync(pdiModelPath, pdiModelDestPath);
    
    await PredictionModel.create({
      name: 'pdi_model',
      version: `${new Date().toISOString().slice(0, 10)}`,
      trainedDate: new Date(),
      metrics: { r2: 0.82 }, // Default metrics, should be updated with actual values
      filePath: pdiModelDestPath,
      isActive: true
    });
    
    // Update environment variables
    process.env.SIZE_MODEL_PATH = sizeModelDestPath;
    process.env.PDI_MODEL_PATH = pdiModelDestPath;
    
    await bot.sendMessage(
      chatId,
      '‚úÖ –ú–æ–¥–µ–ª–∏ —É—Å–ø–µ—à–Ω–æ –∑–∞–≥—Ä—É–∂–µ–Ω—ã –∏ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω—ã. –ü—Ä–æ–≥–Ω–æ–∑—ã —Ç–µ–ø–µ—Ä—å –±—É–¥—É—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –Ω–æ–≤—ã–µ –º–æ–¥–µ–ª–∏.'
    );
    
    logger.info(`Admin ${adminId} reloaded prediction models: size_model=${sizeModelDestPath}, pdi_model=${pdiModelDestPath}`);
  } catch (error) {
    logger.error(`Error reloading models: ${error.message}`);
    await bot.sendMessage(
      chatId,
      '‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –º–æ–¥–µ–ª–µ–π. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.'
    );
  }
}

/**
 * Create a database backup
 * @param {TelegramBot} bot - Telegram bot instance
 * @param {Object} msg - Message object from Telegram
 */
async function createBackup(bot, msg) {
  const chatId = msg.chat.id;
  const adminId = msg.from.id.toString();
  
  try {
    // Send processing message
    const processingMsg = await bot.sendMessage(
      chatId,
      '‚è≥ –°–æ–∑–¥–∞–Ω–∏–µ —Ä–µ–∑–µ—Ä–≤–Ω–æ–π –∫–æ–ø–∏–∏ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö...'
    );
    
    // Create backup directory if it doesn't exist
    const backupDir = path.join(__dirname, '../../../backups');
    if (!fs.existsSync(backupDir)) {
      fs.mkdirSync(backupDir, { recursive: true });
    }
    
    // Generate backup filename
    const backupId = uuidv4();
    const timestamp = new Date().toISOString().replace(/:/g, '-');
    const backupFilename = `backup_${timestamp}_${backupId}.sql`;
    const backupPath = path.join(backupDir, backupFilename);
    
    // Create backup
    await createDatabaseBackup(backupPath);
    
    // Get file size
    const stats = fs.statSync(backupPath);
    const fileSizeMB = stats.size / (1024 * 1024);
    
    // Create backup log entry
    await BackupLog.create({
      logId: backupId,
      backupDate: new Date(),
      adminId,
      fileName: backupFilename,
      size: fileSizeMB
    });
    
    // Update message
    await bot.editMessageText(
      `‚úÖ –†–µ–∑–µ—Ä–≤–Ω–∞—è –∫–æ–ø–∏—è —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω–∞!\n\n` +
      `*ID –∫–æ–ø–∏–∏:* \`${backupId}\`\n` +
      `*–î–∞—Ç–∞/–≤—Ä–µ–º—è:* ${new Date().toLocaleString('ru-RU')}\n` +
      `*–ò–º—è —Ñ–∞–π–ª–∞:* ${backupFilename}\n` +
      `*–†–∞–∑–º–µ—Ä:* ${fileSizeMB.toFixed(2)} –ú–ë\n\n` +
      `–î–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –≤—Å–µ—Ö —Ä–µ–∑–µ—Ä–≤–Ω—ã—Ö –∫–æ–ø–∏–π –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—É:\n` +
      `/admin backup list`,
      {
        chat_id: chatId,
        message_id: processingMsg.message_id,
        parse_mode: 'Markdown'
      }
    );
    
    logger.info(`Admin ${adminId} created backup: ${backupFilename}, size: ${fileSizeMB.toFixed(2)} MB`);
  } catch (error) {
    logger.error(`Error creating backup: ${error.message}`);
    await bot.sendMessage(
      chatId,
      '‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ —Ä–µ–∑–µ—Ä–≤–Ω–æ–π –∫–æ–ø–∏–∏. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.'
    );
  }
}

/**
 * List all database backups
 * @param {TelegramBot} bot - Telegram bot instance
 * @param {Object} msg - Message object from Telegram
 */
async function listBackups(bot, msg) {
  const chatId = msg.chat.id;
  
  try {
    // Get all backup logs
    const backups = await BackupLog.findAll({
      order: [['backupDate', 'DESC']],
      include: [
        {
          model: User,
          attributes: ['name']
        }
      ]
    });
    
    if (backups.length === 0) {
      await bot.sendMessage(
        chatId,
        'üìù –°–ø–∏—Å–æ–∫ —Ä–µ–∑–µ—Ä–≤–Ω—ã—Ö –∫–æ–ø–∏–π –ø—É—Å—Ç. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—É `/admin backup create` –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –Ω–æ–≤–æ–π –∫–æ–ø–∏–∏.'
      );
      return;
    }
    
    // Format the backups message
    let backupsText = `üíæ *–°–ø–∏—Å–æ–∫ —Ä–µ–∑–µ—Ä–≤–Ω—ã—Ö –∫–æ–ø–∏–π* (${backups.length})\n\n`;
    
    for (const backup of backups) {
      const backupDate = new Date(backup.backupDate).toLocaleString('ru-RU');
      const adminName = backup.User ? backup.User.name : '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ';
      
      backupsText += `*ID:* \`${backup.logId}\`\n`;
      backupsText += `*–î–∞—Ç–∞:* ${backupDate}\n`;
      backupsText += `*–ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä:* ${adminName}\n`;
      backupsText += `*–ò–º—è —Ñ–∞–π–ª–∞:* ${backup.fileName}\n`;
      backupsText += `*–†–∞–∑–º–µ—Ä:* ${backup.size ? backup.size.toFixed(2) + ' –ú–ë' : '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ'}\n`;
      backupsText += `*–°—Ç–∞—Ç—É—Å:* ${backup.status === 'completed' ? '‚úÖ –ó–∞–≤–µ—Ä—à–µ–Ω–æ' : '‚ùå –û—à–∏–±–∫–∞'}\n\n`;
    }
    
    backupsText += `–î–ª—è –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è –∏–∑ —Ä–µ–∑–µ—Ä–≤–Ω–æ–π –∫–æ–ø–∏–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—É:\n`;
    backupsText += `/admin backup restore ID_–∫–æ–ø–∏–∏`;
    
    await bot.sendMessage(chatId, backupsText, { parse_mode: 'Markdown' });
    logger.info(`Admin ${msg.from.id} listed backups`);
  } catch (error) {
    logger.error(`Error listing backups: ${error.message}`);
    await bot.sendMessage(
      chatId,
      '‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å–ø–∏—Å–∫–∞ —Ä–µ–∑–µ—Ä–≤–Ω—ã—Ö –∫–æ–ø–∏–π. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.'
    );
  }
}

/**
 * Restore database from backup
 * @param {TelegramBot} bot - Telegram bot instance
 * @param {Object} msg - Message object from Telegram
 * @param {string} backupId - ID of the backup to restore from
 */
async function restoreBackup(bot, msg, backupId) {
  const chatId = msg.chat.id;
  const adminId = msg.from.id.toString();
  
  try {
    // Find the backup
    const backup = await BackupLog.findOne({
      where: { logId: backupId }
    });
    
    if (!backup) {
      await bot.sendMessage(
        chatId,
        '‚ùå –†–µ–∑–µ—Ä–≤–Ω–∞—è –∫–æ–ø–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ ID –∫–æ–ø–∏–∏ –∏ –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.'
      );
      return;
    }
    
    // Confirm restoration
    await bot.sendMessage(
      chatId,
      `‚ö†Ô∏è *–í–ù–ò–ú–ê–ù–ò–ï! –í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ –∏–∑ —Ä–µ–∑–µ—Ä–≤–Ω–æ–π –∫–æ–ø–∏–∏*\n\n` +
      `–í—ã —Å–æ–±–∏—Ä–∞–µ—Ç–µ—Å—å –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö –∏–∑ –∫–æ–ø–∏–∏:\n` +
      `*ID:* ${backup.logId}\n` +
      `*–î–∞—Ç–∞:* ${new Date(backup.backupDate).toLocaleString('ru-RU')}\n` +
      `*–ò–º—è —Ñ–∞–π–ª–∞:* ${backup.fileName}\n\n` +
      `‚ö†Ô∏è –≠—Ç–æ –¥–µ–π—Å—Ç–≤–∏–µ –ø–µ—Ä–µ–∑–∞–ø–∏—à–µ—Ç –í–°–ï —Ç–µ–∫—É—â–∏–µ –¥–∞–Ω–Ω—ã–µ!\n` +
      `‚ö†Ô∏è –ë–æ—Ç –±—É–¥–µ—Ç –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω –≤–æ –≤—Ä–µ–º—è –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è.\n\n` +
      `–î–ª—è –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ:\n` +
      `\`/admin backup confirm ${backupId}\``,
      { parse_mode: 'Markdown' }
    );
    
    logger.info(`Admin ${adminId} requested confirmation for backup restore: ${backupId}`);
  } catch (error) {
    logger.error(`Error preparing backup restore: ${error.message}`);
    await bot.sendMessage(
      chatId,
      '‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–¥–≥–æ—Ç–æ–≤–∫–µ –∫ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—é. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.'
    );
  }
}

/**
 * Show application logs
 * @param {TelegramBot} bot - Telegram bot instance
 * @param {Object} msg - Message object from Telegram
 * @param {string} level - Log level to filter by
 * @param {number} limit - Maximum number of log entries to show
 */
async function showLogs(bot, msg, level, limit) {
  const chatId = msg.chat.id;
  
  try {
    // Validate log level
    const validLevels = ['error', 'warning', 'warn', 'info', 'debug'];
    if (!validLevels.includes(level.toLowerCase())) {
      await bot.sendMessage(
        chatId,
        `‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —É—Ä–æ–≤–µ–Ω—å –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è. –î–æ–ø—É—Å—Ç–∏–º—ã–µ —É—Ä–æ–≤–Ω–∏: ${validLevels.join(', ')}`
      );
      return;
    }
    
    // Map 'warning' to 'warn' for grep
    const grepLevel = level.toLowerCase() === 'warning' ? 'warn' : level.toLowerCase();
    
    // Get log file path
    const logFile = grepLevel === 'error' ? 
      path.join(__dirname, '../../../logs/error.log') :
      path.join(__dirname, '../../../logs/combined.log');
    
    if (!fs.existsSync(logFile)) {
      await bot.sendMessage(
        chatId,
        '‚ùå –§–∞–π–ª –ª–æ–≥–æ–≤ –Ω–µ –Ω–∞–π–¥–µ–Ω. –í–æ–∑–º–æ–∂–Ω–æ, –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –µ—â–µ –Ω–µ —Å–æ–∑–¥–∞–ª–æ —Ñ–∞–π–ª—ã –ª–æ–≥–æ–≤.'
      );
      return;
    }
    
    // Use grep to filter logs
    const { stdout } = await execPromise(`grep -i '${grepLevel}' ${logFile} | tail -n ${limit}`);
    
    if (!stdout.trim()) {
      await bot.sendMessage(
        chatId,
        `üìù –í –ª–æ–≥–∞—Ö –Ω–µ –Ω–∞–π–¥–µ–Ω–æ –∑–∞–ø–∏—Å–µ–π —É—Ä–æ–≤–Ω—è "${level}".`
      );
      return;
    }
    
    // Format log entries
    const logs = stdout.split('\n').filter(line => line.trim());
    let logsText = `üìã *–ü–æ—Å–ª–µ–¥–Ω–∏–µ ${logs.length} ${level} –ª–æ–≥–æ–≤*\n\n`;
    
    logs.forEach((log, index) => {
      logsText += `*${index + 1}.* \`${log}\`\n\n`;
    });
    
    // Split message if it's too long
    if (logsText.length > 4000) {
      const chunks = [];
      for (let i = 0; i < logsText.length; i += 4000) {
        chunks.push(logsText.slice(i, i + 4000));
      }
      
      for (let i = 0; i < chunks.length; i++) {
        await bot.sendMessage(
          chatId,
          `${i === 0 ? '' : '(–ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏–µ) '}${chunks[i]}`,
          { parse_mode: 'Markdown' }
        );
      }
    } else {
      await bot.sendMessage(chatId, logsText, { parse_mode: 'Markdown' });
    }
    
    logger.info(`Admin ${msg.from.id} viewed ${level} logs, limit ${limit}`);
  } catch (error) {
    logger.error(`Error showing logs: ${error.message}`);
    await bot.sendMessage(
      chatId,
      '‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –ª–æ–≥–æ–≤. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.'
    );
  }
}

module.exports = {
  addUserToWhitelist,
  removeUserFromWhitelist,
  listWhitelistedUsers,
  listModels,
  reloadModels,
  createBackup,
  listBackups,
  restoreBackup,
  showLogs
};